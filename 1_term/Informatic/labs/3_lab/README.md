## Лабораторная работа 3

В Лабораторной работе 3 вы познакомитесь с функциями, циклами и массивами. Ход работы:

1. Склонировать репозиторий.

2. Создать файл `script.bash`

3. Реализовать в файле `script.bash` функцию, которая будет выводить в определенном формате в стандартный вывод дерево директорий и файлов для заданного пути и их количество.

4. Загрузить решение на `GH`.

*Warning!* Для тестирования написанной вами программы будет использоваться абстрактная иерархия файлов и директорий `./dir`.

### Задача

Вывести все директории и файлы по заданному пути. В конце на новой строке вывести количество директорий и файлов (смотрите пример выходных данных, либо вывод утилиты `tree` без параметров).

*Attention!* Запрещено использовать утилиту `tree`.

#### Входные данные

Едининственный аргумент скрипта путь в виде (путь может отличаться от представленного примера)

```bash
bash script.bash .
```

#### Выходные данные

В стандартный вывод вывести структуру в виде

```bash
.
├── abc
├── aberdeen
│   ├── aa
│   │   ├── aa
│   │   │   └── aaa.txt
│   │   ├── aaa
│   │   │   ├── ability
│   │   │   │   ├── abc
│   │   │   │   ├── abilities
│   │   │   │   │   ├── aa.txt
│   │   │   │   │   └── ab
│   │   │   │   │       └── abandoned.pdf
│   │   │   │   ├── ability
│   │   │   │   │   └── aberdeen
│   │   │   │   └── ab.txt
│   │   │   └── ab.pdf
│   │   └── aaa.doc
│   ├── aa.jpg
│   └── ab
│       └── aa.jpeg
└── abilities
    └── aaa.txt

10 directories, 12 files
```
### Дополнительная информация к выполнению лабораторной работы
*Hint!* Необходимо прописать ```export LANG=en_US.UTF-8```

*Hint!*

#1 Подсказки по использованию инструментов языка.

МАССИВЫ.

Создание массива со всеми поддиректориями текущей директории
```subdirs=(root/*)    # Внутри будет ( root/five  root/one  root/six )```

Количество поддиректорий
```subdir_count=${#subdirs[@]}```

Вывести поддиректорию i
```echo ${subdirs[i]}```

Удаление части строки

поиск подстроки ведется сначала строки
```echo ${subdirs[@]##*/}  # Output: ( five one six )```

поиск подстроки ведется с конца строки
```echo ${subdirs[@]%%*/}  # Output: ( root root root )```

КОДИРОВКИ (Да, даже если вы не видите символы, они могут быть разными :) ).

Рекомендуем поисследовать различные тексты, которые вы видите в терминале в, например, этом [сервисе.](https://r12a.github.io/app-conversion/)

А также прочитать про [кодировки.](https://guides.hexlet.io/encoding/)

Это совершенно точно сэкономит массу вашего времени и нервов в будущем :)

Так, существует множество представлений символов. Например, в Unicode, необходимые нам символы имеют вид
```
printf "\u2502"   # │
printf "\u251c"   # ├
printf "\u2500"   # ─
printf "\u2514"   # └
printf "\u00A0"   # non-breaking space
printf "\u0020"   # space
printf "\n"       # перенос строки (в linux)
```

Например, если нужно вывести вот это

```│   └── two```

лучшим способ сделать это будет

```printf "\u2502\u00A0\u00A0\u0020\u2514\u2500\u2500\u0020 two"```

#2 Алгоритм.

Поисследовав утилиту tree и проанализировав ее вывод в Unicode декодере (ссылка выше), становится понятно, что любая строка состоит из
${parent}${child}${name}

Например,
```
│   │   │   │   ├── four.jpg
здесь
${parent} =
│   │   │   │   
${child} = 
├── 
${name} = 
four.jpg
```

### Дополнительные источники

* [Функции](https://se.ifmo.ru/~ad/Documentation/ABS_Guide_ru.html#FUNCTIONS)

* [Функции и рекурсивные функции](https://habr.com/ru/company/ruvds/blog/327248/)

* [Циклы](https://se.ifmo.ru/~ad/Documentation/ABS_Guide_ru.html#LOOPS)

* [Локальные переменный](https://se.ifmo.ru/~ad/Documentation/ABS_Guide_ru.html#LOCALVAR)

* [Массивы](https://se.ifmo.ru/~ad/Documentation/ABS_Guide_ru.html#ARRAYS)
